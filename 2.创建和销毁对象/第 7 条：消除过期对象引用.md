# 第 7 条：消除过期对象引用

如果你从诸如 C 或 C++ 这种手动管理内存的语言，切换到了像 Java 这种具有垃圾回收的语言，当你使用完对象后，它们会被自动回收这一事实，会使得你作为程序员的工作变得更加轻松。当你第一次体验到垃圾回收机制时，它就像魔法一般。它很容易给你留下这样的印象，你不需要去考虑内存管理这件事请，然而事实并非如此 。

考虑下面这个简单的栈实现的例子：

```java
// 你可以认出 “内存泄露” 吗
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) throw new EmptyStackException();
        return elements[--size];
    }

    /**
     * 确保至少有一个元素的空间，每次数组需要增长时，容量大约增加一倍。
     */
    private void ensureCapacity() {
        if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

这个程序没有明显的错误（但泛型版本请查看 [第 29 条][item29]）。你可以对它进行全面的测试，它可以出色地通过各种测试，但程序中潜藏着一个问题。 不严格地讲，程序中存在“内存泄漏（memory leak）”，由于垃圾收集器的活动的增加或者内存占用增加，程序性能下降会默默的表现出来。在极端的例子中，这样的内存泄漏会导致磁盘交换（disk paging），甚至导致程序失败，并出现 OutOfMemoryError 错误。但这种失败情形相对比较少见。

那么，程序中哪里发生了内存泄漏？如果一个栈增长，然后缩小，被弹出栈的对象将不会被垃圾回收，甚至使用栈的程序不再引用它们。这是因为栈维护着对这些对象的过期引用（obsolete reference）。所谓的过期引用，是指永远也不会再被解除的引用。在这个例子中，任何在元素数组中的“活跃部分（activce portion）”之外的引用都是过时的。活跃部分由小标小于 size 的元素组成。

垃圾回收语言中的内存泄漏（更恰当地称为无意识的对象保留（unintentional object retention））是隐蔽的。如果一个对象引用被无意识的保留，不仅仅是这个对象会被垃圾回收排斥，而且任河被这个对象引用的对象也是如此。即使只有很少的对象被无意的保留，许多许多的对象也可能被阻止垃圾回收，这对性能而言有着潜在的巨大影响。

这类问题的修复很简单：一旦引用过时就将它们清空。在我们 Stack 类的例子中，一个对象的引用被弹出栈后，很快就会变得过时，pop 方法的正确版本如下所示：

```java
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null;
        // 消除过期引用
        return result;
    }
```

清空过期引用的一个额外好处就是，如果它们之后被错误地解除引用，程序将会立刻失败，并抛出 NullPointerException 异常 ，而不是悄悄地做错误的事。尽可能快的检测出程序的错误总是有好处的。

当程序员第一次被这个问题所困扰时，他们可能会在程序使用完毕后立即清空每个对象引用，从而过度补偿。这既没必要，也不可取，因为它会对程序造成不必要地干扰。**清空对象引用应该是例外，而非规范**。消除过期引用的最佳方式，就是让包含了引用的变量超出它的作用域。如果你在尽可能紧凑的作用域范围内定义每个变量，这种情形就会自然而然的发生。

那么，什么时候应该消除引用呢？Stack 类的哪个方面使其易受内存泄漏的影响呢？简单的说，问题在于，它管理它自己的内存（manage its own memory）。存储池包含 elements 数组的元素（对象引用单元，而不是对象本身）。数组的活跃部分（同前面定义的）的元素是已分配（allocated），而数组其余部分则是自由的（free）。垃圾收集器并不知道这一点。对垃圾收集器而言，elements 数组中所有的对象引用都是同等有用的。只有程序员知道，数组的不活跃部分（inactive portion）是不重要的。一旦数组元素编程不活跃部分的一部分，程序员就会通过手动清空数组元素，以有效地告知垃圾收集器这一情况。

一般而言，**一个类无论任何时候管理它自己的内存，程序员都应该警惕内存泄漏** 。一个元素无论任何时候被释放，元素中包含的任何对象引用都应当被清空。

**内存泄漏的另一个常见来源是缓存**。一旦你把一个对象引用放入缓存中，就会很容易忘记它在里面，并且在它变得无关紧要后，会被长时间留在缓存中。对于这个问题，有多个解决方案，如果你足够幸运的话，只要在缓存之外有对其键（key）的引用，就可以实现项（entry）是相对精确的缓存，那么就可以用 WeakHashMap 代替。在项变得过时后，它将会被自动清除。记住只有当所期望的缓存的生命周期是由键的外部引用决定的，而不是值来决定时，WeakHashMap 才是有用的。

更常见的是，缓存项的有用生命周期定义不太明确，随着时间的推移，缓存项会变得不那么有价值。在这种情况下，缓存应该偶尔清除已经不用的项。这个可以由后台线程（可能是 ScheduledThreadPoolExecutor）来完成，或者作为向缓存中添加新缓存项的副作用来完成。LinkedHashMap 类使用 removeEldestEntry 方法来促进后一种方法。 对于更复杂的缓存，您可能需要直接使用 java.lang.ref。

 **内存泄露的第三个常见来源是监听器（listener）或者其它回调（callback）**。如果你实现了一个 API，其中客户端注册回调但未明确撤销它们，除非采取一些措施，否则它们就会累积。确保回调被及时垃圾回收的一种方式，就是仅存储对它们的弱引用（weak reference），例如，通过仅将它们存储为 WeakHashMap 中的键来实现。

因为内存泄漏通常不会表现为明显的失败，它们可能在一个系统中存在多年。它们通常仅在仔细的代码检查或者借助被称为 heap profile 的调试工具的情况下才被发现。因此，学会在内存泄漏发生之前预测到这样的问题并阻止它们发生，这是非常有必要的。


[item29]:url	"在未来填入第 29 条的 url，否则无法进行跳转" 

---

> 翻译：Inno