# 第 7 条：消除过期对象引用

【作为一名程序员，】如果你从诸如 C 或 C++ 这种手动管理内存的语言~~，~~切换到~~了~~像 Java 这<u>种</u>【样】具有垃圾回收的语言，<u>当你使用完对象后，它们会被自动回收这一事实，会使得你作为程序员的工作变得更加轻松。</u> 【你的工作会变得更加轻松，因为对象在使用完后会被自动回收。】当你第一次体验到垃圾回收机制时，它就像魔法一般。<u>它很容易给你留下这样的印象，</u> 【垃圾回收机制很容易误导你让你觉得】你不需要去考虑内存管理这件事~~请~~，然而事实并非如此 。

~~考虑~~【思考一下】下面这个【实现】简单的栈~~实现~~的例子：

```java
// 你可以认出 “内存泄露” 吗？
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) throw new EmptyStackException();
        return elements[--size];
    }

    /**
     * 确保至少有一个元素的空间，每次数组需要增长时，容量大约增加一倍。
     */
    private void ensureCapacity() {
        if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

这个程序没有明显的错误（~~但~~泛型版本请查看 [第 29 条][item29]）。<u>你可以对它进行全面的测试</u>【无论你怎么测试】，它【都】可以出色地通过~~各种测试~~，但程序中潜藏着一个问题。 不严格地讲，程序中存在【着】“内存泄漏（memory leak）”，~~由于~~【随着】垃圾收集器的活动~~的~~增加或者内存占用增加，程序性能【的】下降会<u>默默的</u>【慢慢】表现出来。在极端~~的例子中~~【情况下】，这样的内存泄漏会导致磁盘交换（disk paging），甚至【出现 OutOfMemoryError错误】导致程序失败~~，并出现 OutOfMemoryError 错误~~ ，<u>但</u> 【不过】这种失败【的】情形相对比较少见。

那么，程序中哪里发生了内存泄漏【呢】？如果一个栈【的长度先】增<u>长</u>【大】然后<u>缩</u>【减】小，<u>被弹出栈的对象将不会被【垃圾】回收</u>【那么垃圾回收机制不会回收那些从栈中弹出来的对象】，~~甚至使用栈的程序不再引用它们~~ 【即使使用栈的程序不再引用这些对象，它们也不会被回收】。这是因为栈【内部】维护着对这些对象的过期引用（*obsolete reference*）。所谓的过期引用，是指永远也不会再被【主语】<u>解除</u>释放的引用。在这个例子中，【除了 elements 数组中的“活跃部分（active portion）“，其余的所有引用都是过时的】<u>任何【所有】在 elements 数组中的“活跃部分（activce portion）”之外的引用都是过时的</u>。活跃部分【是指下标】~~由小标~~小于 size 的【那些】元素~~组成~~。

> ps: 所谓过期引用，是指永远也不会被【主语】释放的引用。
>
> 直接改成主动语态更符合中国人的阅读习惯，所谓的过期应用就是指那些【主语】永远不会再释放的引用。

【在支持】垃圾回收【机制】语言中~~的~~，内存泄漏【问题】（更恰当地称【其】为无意识的对象保留（*unintentional object retention*））是【很】隐蔽的。如果一个对象引用被无意识的保留【下来】，<u>不仅仅是这个对象会被垃圾回收排斥</u>【垃圾回收器不仅仅不会回收这个对象】，~~而且~~<u>任河被这个对象引用的对象也是如此</u>【也不会回收被这个对象引用的所有其它对象】。即使只有很少的对象【会】被无意【识地】保留【下来】，【也可能会有】<u>许多许多</u>【许许多多】的对象也~~可能~~被<u>阻止</u>【排除在】垃圾回收【机制之外】，这对性能而言有着潜在的巨大影响。

这类问题的修复很简单：一旦【对象】引用<u>过时</u>【过期】，就将它们清空【即可】。在我们 Stack 类的例子中，【一旦】一个对象~~的引用~~被弹出栈后，【指向它的引用】很快就会~~变得~~<u>过时</u>【过期】，pop 方法的<u>正确</u>【修正】版本如下所示：

> the *reference* to **an item** *becomes obsolete* as soon as **it’s** popped off the stack.    
>
> 第二个 It‘s 指的是栈中的单元被弹出，那么指向它的引用会过期。

```java
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null;
        // 消除过期引用
        return result;
    }
```

清空过期引用<u>的一个额外</u>【还有另一个】好处~~就是~~，如果它们之后被错误地解除引用，程序将会立刻<u>失败</u>【崩溃】并抛出 NullPointerException 异常 ，而不是悄悄地<u>做错误的事</u>【错误运行下去】。尽可能快<u>的</u>【地】检测出程序的错误总是有好处的。

当程序员第一次被这<u>个</u>【种】问题所困扰时，他们<u>可能会</u>【往往反应过度：对于每个对象的引用，一旦程序不再使用它就立即把它清空。】~~在程序使用完毕后立即清空每个对象引用，从而过度补偿~~。这既没必要，也不可取，因为它会对程序造成不必要地干扰。**清空对象引用应该<u>是例外</u>【个例】，而非<u>规范</u>【常规情况】**。<u>消除过期引用的最佳方式，就是让包含了引用的变量超出它的作用域</u>【让包含了过期引用的变量超出它的作用域是消除过期引用的最佳方法】。如果你在尽可能紧凑的作用域~~范围~~内定义每个变量，这种情形就会自然而然的发生（[第 57 条][Item57]）。

> nulling out **every object reference** as soon as the program is finished using **it**.    

那么，什么时候应该<u>消除</u>【清空】引用呢？Stack 类的哪~~个~~方面【特性】使其易受内存泄漏的影响呢？简单<u>的</u>【来】说，问题在于~~，它管理它自己的内存~~ 【Stack 类自己管理内存】（manage its own memory）。存储池（*storage pool*）<u>包含</u>【由】 elements 数组的元素（对象引用单元，而不是对象本身）【组成】。数组的活跃部分（同前面定义的）的元素是已分配（*allocated*）【状态】，而数组其余部分则是自由<u>的</u> 【状态】（free）。<u>垃圾收集器</u>并不知道这一点；对<u>垃圾收集器</u>而言，elements 数组中所有的对象引用都是同等<u>有用</u>【有效】的。只有程序员知道~~，~~数组的<u>不</u> 【非】活跃部分（inactive portion）是<u>不重要</u>【无关紧要】的。【程序员可以高效地把这一情况告知垃圾回收器：】一旦数组元素<u>编程不</u>【变成非】活跃部分~~<u>的一部分</u>~~，程序员就~~会通过~~手动清空数组元素~~，以有效地告知垃圾收集器这一情况~~。

> 垃圾回收器我觉得更好一点，因为前面都用的是垃圾回收机制、垃圾回收器。

一般而言，**<u>一个类管理它自己的</u>【无论任何时候一个类自己管理】内存，程序员都应该警惕内存泄漏【问题】** 。【无论任何时候释放】一个元素~~无论任何时候~~~~被释放~~，【则该】元素中包含的任何对象引用都应当被清空。

**内存泄漏的另一个常见来源是缓存**。<u>一旦你把一个对象引用放入缓存中</u>【当你把对象引用放入缓存中后】，~~就~~会很容易忘记它~~在里面~~【的存在】，~~并且~~在它变得无关紧要后【依然】会~~被~~长时间留在缓存中。~~对于~~这个问题~~，~~有多个解决方案。如果你足够幸运的话【，可以实现一个与项（entry）完全相关的缓存：】只要在缓存之外有对<u>其</u>【某个项】键（key）的引用~~，就可以实现项（entry）是相对精确的缓存~~，那么就可以用 WeakHashMap 代替。在【缓存中的】项<u>变得过时</u>【过期】后，它【们】将会被自动清除。记住只有当所<u>期望</u>【需要】的缓存【项】的生命周期是由该键的外部引用决定~~的，~~而不是值来决定时，WeakHashMap 才是有用的。

> If you’re lucky enough to implement a cache for which an entry is relevant exactly so long as there are references to its key outside of the cache, represent the cache as a WeakHashMap; entries will be removed automatically after they become obsolete.
>
> 对不起这句话我真的看不懂，尽力了。

更常见的【情况】是，缓存项~~的~~【真正有价值的】<u>有用</u>生命周期定义不太明确，随着时间的推移，缓存项会变得<u>不那么</u>【越来越没】有价值。在这种情况下，缓存应该<u>偶尔</u>【不时地】清除已经不用的项。这个【任务】可以由后台线程（可能是 ScheduledThreadPoolExecutor）来完成，或者<u>作为向缓存中添加新缓存项的副作用来完成</u>【也可以在向缓存中添加新缓存项时顺便清理】。LinkedHashMap 类使用 removeEldestEntry 方法<u>来促进后一种方法</u>【可以轻松实现后者】。 对于更复杂的缓存，您【你】~~可能~~需要直接使用 java.lang.ref。

 **内存泄露的第三个常见来源是监听器（listener【s】）~~或者~~【和】其它回调（callback【s】）**。如果你实现了一个 API，~~其中~~客户端【在这个 API 中】注册回调但未明确撤销它们，【那么】除非采取一些措施，否则它们就会累积。【仅存储对它们的弱引用（weak reference）是】确保回调被及时【当作】垃圾回收的一种方式~~，就是仅存储对它们的弱引用（weak reference）~~，例如，~~通过~~仅将它们存储为 WeakHashMap 中的键~~来实现~~。

<u>因为</u>【由于】内存泄漏通常不会表现为明显的<u>失败</u>【故障/错误/崩溃】，【所以】它们可能在一个系统中存在多年。<u>它们通常仅在</u>【往往只有通过】仔细的代码检查或者借助被称为 heap profile 的调试工具~~的情况下~~才~~被~~【能】发现。因此，学会在内存泄漏发生之前预测到这样的问题【，】并阻止它们发生，<u>这是非常有必要的</u>【那才是极好的】。

[item29]:url	"在未来填入第 29 条的 url，否则无法进行跳转"
[Item57]:url	"在未来填入第 57 条的 url，否则无法进行跳转"

---

> 翻译：Inno
>
> 校对：Inger