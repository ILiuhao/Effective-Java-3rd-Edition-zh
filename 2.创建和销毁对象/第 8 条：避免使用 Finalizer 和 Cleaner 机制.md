# 避免使用终止方法（finalizers）和清除方法（cleaners）

**终止方法不可预测，通常都是不安全的，而且通常情况下都不是必须使用的方法。**终止方法的使用会导致程序执行的不稳定，降低程序性能以及可移植性问题。终止方法很少情况下有用，在本节的后面部分会做介绍，但根据经验来看，你应该避免使用这种机制。在 JAVA 9 中终止方法已经被弃用了，然而在一些 JAVA 函数库中依然可以看到它们的身影。在 JAVA 9 中清除方法是终止方法的替代物。**清除方法比终止方法安全性更高一些，但依然是不可预测的，会使程序运行缓慢，通常情况下依然是不必要的**。

不要把 JAVA 的终止方法或清除方法与 C++ 中的析构函数当成类似的机制。在 C++ 中，析构函数是回收对象资源的标准方法，而且也是与构造函数配对的必要的函数。在 Java 中，垃圾回收机制回收不可用对象所占空间时是不需要程序员做额外工作的。C++ 的析构函数也可以回收其他非内存资源，而在 JAVA 中，一般用 `try-with-resources` 或者 `try-finally` 块达到同样的目的（[第 9 条][Item9]）。

终止方法和清除方法不能保证其被迅速执行是它的一大缺点。当对象变得不可达时，终止方法或清除方法的执行时间是不固定的。这意味着**不应该在终止方法或清除方法中执行任何对时序要求严格的任务（time-critical）**。比如，依靠终止方法或清除方法完成关闭已达开文件操作会导致严重错误，因为打开文件的描述符是一种很有限的资源。由于 JVM 会延迟执行终结方法或清除方法，所以大量文件会保留在打开状态，当一个程序不能再打开文件时，它可能会运行失败。

及时地执行终止方法和清除方法正是垃圾回收算法的主要功能，然而这种算法在 JVM 实现中过程中却大变化很大，取决于终止方法或清除方法执行效率的程序性能也可能不同。这样的程序在你测试用的 JVM 平台上运行得非常好，然后在你最重要的客户的 JVM 平台上却根本无法运行，这种情况是完全有可能发生的。

缓慢终止不仅仅只是一个理论上的问题。给一个类添加终止方法可以任意地延迟回收该类实例的过程。我的一位同事在调试一个长期运行的 GUI 应用时，程序莫名其妙报了内存溢出（`OutOfMemoryError`）的错误，然后谜之崩溃。我们分析程序崩溃的原因时发现，这个应用程序的终止队列中有成千上万个图对象（graphics objects）在等着被终止和回收。不幸的是这个终止方法线程比该程序的其它线程的优先级低，所以这些对象终止的速度不能达到它本应该达到的速度。JAVA 语言并不能保证哪个线程会执行终止方法，所以除了避免使用终止方法之外，没有别的方法来防止这类问题。在这方面清除方法比终止方法好一点，因为类的作者可以控制该类的清除方法线程，但是清除方法依然会在垃圾回收器的控制下在后台运行，所以也不能保证及时清除方法的及时运行。

JAVA 语言不仅不能保证终止方法或清除方法的及时执行，它甚至都不能保证它们会被执行。当程序终止时，某些已经无法访问的对象的终止方法却根本没有执行，这也是完全有可能的情况。所以，**永远不要使用终止方法或清除方法来更新重要的持久状态**。比如，使用终止方法或清除方法释放共享资源（比如数据库）上的永久锁，很容易让整个分布式系统垮掉。

不要被 `System.gc`  和 `System.runFinalization` 这两个方法诱导。它们可能会提高终止方法或清除方法被执行的几率，但也不保证它们一定会被执行。有两种方法曾经作出这样的保证：`System.runFinalizersOnExit` 和它的兄弟 `Runtime.runFinalizersOnExit` 。然而这些方法有致命缺陷并且已经被贬低了十几年[ [ThreadStop][ThreadStop] ]。

终止方法存在另外一个问题，在终止过程中抛出的未被捕获的异常会被忽略，并且会停止对象的终止过程 [JSL, 12.6]。这些被忽略的异常会使其他对象处于被破坏（a corrupt state）的状态。如果其他线程使用了这些被破坏的对象，将会导致任意不可预测的结果。一般地，未被捕获的异常会终止终止线程并打印出栈轨迹（stack trace），但在终止方法中却不会这么做——它不会打印出任何一条警告信息。清除方法没有这个问题，因为使用清除方法的库可以控制它的线程。

**使用终止方法或清除方法会导致严重的性能损失**。在我的机器上创建一个简单的 `AutoCloseable` 对象来关闭它使用的 `Try-with-resources` 并让垃圾回收器回收其所占用的资源所用的时间仅仅只有 12ns，而使用终止方法达到了 550ns。换句话说，使用终止方法创建并销毁对象比不使用它时间慢了 50 倍。主要是因为终止方法抑制了高效的垃圾回收。如果你使用清除方法来清除类的实例，速度和终止方法差不多（在我的机器上野差不多是 500ns），但如果你把清除方法作为安全网（safety net）来使用，清除方法速度将会快的多。在这种情况下，创建、清除并销毁对象在我的机器上花了 66ns，这意味着如果你不适用安全网，为了保险你要付出 5（不是50）倍的代价。

**终止方法还有一个严重的安全问题：它们会使你的类受到终止方法攻击**（*finalizer attacks*）。终止方法攻击很简单：如果从构造器或它的序列化等价物——`readObject` 和 `readResolve` 方法（[第 12 条][Item12]）——抛出一个异常，恶意子类的终止方法就可以在部分构造的对象上运行，而这些对象本应该“死在藤蔓上”。这个终止方法可以在静态字段中记录对象的引用，从而防止对该对象进行垃圾回收。一旦记录了格式错误的对象（malformed object），在这个早就应该被销毁的对象上任意调用方法就会变得非常简单。**从构造器中抛出异常时，对象就不应该被创建，而终止方法面前却不是这样**。这样的攻击会导致可怕的结果。Final 类避免了终止方法攻击因为没人能给 final 类添加一个恶意子类。**为了让非 final 类避免终止方法攻击，请写一个不执行任何操作的 final 终止方法 **。

那么对于对象封装资源需要被终止的类，比如文件或线程相关类，不使用其终止方法或清除方法，你应该怎么做呢？**让你的类实现 `AutoCloseable` 接口**，并且让客户端在每个实例不在被需要时调用 `close` 方法，通常使用 `Try-with-resources` 保证一旦出现异常确保其终止（[第 9 条][Item9]）。有个值得注意的细节，实例必须持续跟踪它是否被关闭：`close` 方法必须在一个字段中记录该对象是无效的，然后另一个方法必须检查这个字段，如果在该对象已经被关闭后请求则抛出 `IllegalStateException` 异常。

那么，终止方法和清除方法有没有什么用处呢？它们可能有两种合法用途。一种用途是当对象的所有者忘记调用前面段落中建议使用的 `close` 方法的时，它们可以作为安全网（safety net）。虽然不能保证清除方法或终止方法会及时运行（或者根本不运行），那也比如果客户端不调用就永远不释放资源强得多。如果你正考虑写安全网终止方法，建议你三思这种额外的保护是否值得你付出这份额外的代价。比如 `FileInputStream`、`FileOutputStream`、`ThreadPoolExecutor` 和 `java.sql.Connection` 这些依赖库类，就使用的作为安全网的终止方法。

另一种清除方法的合法用途与本地对等体（*native peer*s）有关。本地对等体是一个本地对象（非 Java 对象），普通对象通过本地方法委托给一个本地对象。因为本地对等体不是普通对象，所以垃圾回收器并不知道它的存在，所以当它的 Java 对等体被回收的时候它不会被回收。假设程序性能是可接受的而且本地对等体不含有关键资源，这样的情况下，清除方法或终止方法正好能派上用场。如果性能不可接受或者本地对等体含有必须被及时回收的资源，你应该使用前面段落中建议的 `close` 方法。

清除方法使用起来有些棘手。下面用一个简单的 `Room` 类演示一下。假设 Room 的对象必须在它被回收前清除。`Room` 类实现了 `AutoCloseable` 接口，意味着它可以使用清除方法自动清除安全网。与终止方法不同，清除方法不会污染类的公共 API：

```java
//一个使用清除方法作为安全网的 AutoCloseable 类
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();
    
    // 需要打扫的房间，一定不要认为与房间有关!
    private static class State implements Runnable {
        int numJunkPiles; // 房间里的垃圾堆数量
        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        } 
        
        // 由 close 方法或清除方法调用
        @Override 
        public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }
    } 
    // 这个房间的状态, 与我们定义的 cleanable 共享
    private final State state;
    // 我们定义的 cleanable. 当可以获得垃圾回收器时清理房间
    private final Cleaner.Cleanable cleanable;
    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    } 
    @Override 
    public void close() {
        cleanable.clean();
    }
}
```

静态内部类 `State` 含有清除方法所需要的资源来清理房间。使用 `numJunkPiles` 变量简单的表示房间中的垃圾。更实际地说，它可能包含了一个指向本地对等体的 `long` 常量指针。`State` 实现了`Runnable` 接口并且它的 `run` 方法只能被 `Cleanable` 调用一次，`cleanbale` 就是在 `Room` 构造器中把带有清除方法的 `State` 的实例添加时获得的对象。run 方法的调用会触发两件事：通常 Room 的 close 方法的调用会触发 Cleanable 的 clean 方法。如果在 Room 实例可以被回收时客户端调用 close 方法失败，清除方法将会有效的调用 State 类的 run 方法。

State 实例与 Room 实例无关，这一点至关重要。如果不是的话，将会使 Room 实例变得不可被回收（也不会被自动清理）。非静态内部类包含对它们封闭实例的引用（[第 24 条][Item24]），因此，State 必须是静态内部类。同样，使用 lambda 表达式也是不可取的，因为它们可以轻易捕获对封闭对象的引用。

前面段落中提到，Room 的清除方法仅仅是用来作为安全网的。如果客户端把所有的 Room 对象包含在 try-with-resource 块中实例化，就再也不需要自动清理了。下面这个行为良好的客户端演示了这种方式：

```java
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
            System.out.println("Goodbye");
        }
    }
}
```

运行 Adult 程序，会向你期望的那样，在清理房间后输出 Goodbye。那么永远不会清扫房间的坏程序是怎样的呢？

```java
public class Teenager{
    public static void main(String[] args){
        new Room(99);
        System.out.println("Peace out");
    }
}
```

你可能会期望它在清理完房间后打印出 Peace out，然而在我的机器上，它从没有打印过 Cleanning room ，它只会退出程序。这就是我们之前谈到的不可预测性。清除方法的规范这样说：“在 `System.exit` 的过程中清除方法的行为是具体的。关于是否调用清除操作并没有保证。”即使规范不这么说，对于正常程序退出也是如此。在我的机器上，给 Teenager 的 main 方法添加一行 `System.gc()` 就可以让它在退出程序前打印出 `Cleaning room`  ，但不保证你能在你的电脑上看到同样的情形。

总之，不要使用清除方法或在 Java 9 之前的终止方法，除非作为安全网或终止非关键的本地资源。即使这样，也要注意不确定性和性能带来的后果。

[Item9]: url	"在未来填入第 9 条的 url，否则无法进行跳转"
[Item12]: url	"在未来填入第 12 条的 url，否则无法进行跳转"
[Item24]: url	"在未来填入第 24 条的 url，否贼无法进行跳转"
[ThreadStop]: 为什么Thread,stop,Thread.suspend,Thread.resume和Runtime.runFinalizersOnExit会被贬低？	"https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPri"

