# 避免使用终止方法（finalizers）和清除方法（cleaners）

**终止方法不可预测，通常都是不安全的，而且通常情况下都不是必须使用的方法。**终止方法的使用会导致程序执行的不稳定，降低程序性能以及可移植性问题。终止方法很少情况下有用，在本节的后面部分会做介绍，但根据经验来看，你应该避免使用这种机制。在 JAVA 9 中终止方法已经被弃用了，然而在一些 JAVA 函数库中依然可以看到它们的身影。在 JAVA 9 中清除方法是终止方法的替代物。**清除方法比终止方法安全性更高一些，但依然是不可预测的，会使程序运行缓慢，通常情况下依然是不必要的**。

不要把 JAVA 的终止方法或清除方法与 C++ 中的析构函数当成类似的机制。在 C++ 中，析构函数是回收对象资源的标准方法，而且也是与构造函数配对的必要的函数。在 Java 中，垃圾回收机制回收不可用对象所占空间时是不需要程序员做额外工作的。C++ 的析构函数也可以回收其他非内存资源，而在 JAVA 中，一般用 `try-with-resources` 或者 `try-finally` 块达到同样的目的（[第 9 条][Item9]）。

终止方法和清除方法不能保证其被迅速执行是它的一大缺点。当对象变得不可达时，终止方法或清除方法的执行时间是不固定的。这意味着**不应该在终止方法或清除方法中执行任何对时序要求严格的任务（time-critical）**。比如，依靠终止方法或清除方法完成关闭已达开文件操作会导致严重错误，因为打开文件的描述符是一种很有限的资源。由于 JVM 会延迟执行终结方法或清除方法，所以大量文件会保留在打开状态，当一个程序不能再打开文件时，它可能会运行失败。

及时地执行终止方法和清除方法正是垃圾回收算法的主要功能，然而这种算法在 JVM 实现中过程中却大变化很大，取决于终止方法或清除方法执行效率的程序性能也可能不同。这样的程序在你测试用的 JVM 平台上运行得非常好，然后在你最重要的客户的 JVM 平台上却根本无法运行，这种情况是完全有可能发生的。

缓慢终止不仅仅只是一个理论上的问题。给一个类添加终止方法可以任意地延迟回收该类实例的过程。我的一位同事在调试一个长期运行的 GUI 应用时，程序莫名其妙报了内存溢出（`OutOfMemoryError`）的错误，然后谜之崩溃。我们分析程序崩溃的原因时发现，这个应用程序的终止队列中有成千上万个图对象（graphics objects）在等着被终止和回收。不幸的是这个终止方法线程比该程序的其它线程的优先级低，所以这些对象终止的速度不能达到它本应该达到的速度。JAVA 语言并不能保证哪个线程会执行终止方法，所以除了避免使用终止方法之外，没有别的方法来防止这类问题。在这方面清除方法比终止方法好一点，因为类的作者可以控制该类的清除方法线程，但是清除方法依然会在垃圾回收器的控制下在后台运行，所以也不能保证及时清除方法的及时运行。

JAVA 语言不仅不能保证终止方法或清除方法的及时执行，它甚至都不能保证它们会被执行。当程序终止时，某些已经无法访问的对象的终止方法却根本没有执行，这也是完全有可能的情况。所以，**永远不要使用终止方法或清除方法来更新重要的持久状态**。比如，使用终止方法或清除方法释放共享资源（比如数据库）上的永久锁，很容易让整个分布式系统垮掉。

不要被 `System.gc`  和 `System.runFinalization` 这两个方法诱导。它们可能会提高终止方法或清除方法被执行的几率，但也不保证它们一定会被执行。有两种方法曾经作出这样的保证：`System.runFinalizersOnExit` 和它的兄弟 `Runtime.runFinalizersOnExit` 。然而这些方法有致命缺陷并且已经被贬低了十几年[ [ThreadStop][ThreadStop] ]。

终止方法存在另外一个问题，在终止过程中抛出的未被捕获的异常会被忽略，并且会停止对象的终止过程 [JSL, 12.6]。这些被忽略的异常会使其他对象处于被破坏（a corrupt state）的状态。如果其他线程使用了这些被破坏的对象，将会导致任意不可预测的结果。一般地，未被捕获的异常会终止终止线程并打印出栈轨迹（stack trace），但在终止方法中却不会这么做——它不会打印出任何一条警告信息。清除方法没有这个问题，因为使用清除方法的库可以控制它的线程。

**使用终止方法或清除方法会导致严重的性能损失**。在我的机器上创建一个简单的 `AutoCloseable` 对象来关闭它使用的 `Try-with-resources` 并让垃圾回收器回收其所占用的资源所用的时间仅仅只有 12ns，而使用终止方法达到了 550ns。换句话说，使用终止方法创建并销毁对象比不使用它时间慢了 50 倍。主要是因为终止方法抑制了高效的垃圾回收。如果你使用清除方法来清除类的实例，速度和终止方法差不多（在我的机器上野差不多是 500ns），但如果你把清除方法作为安全网（safety net）来使用，清除方法速度将会快的多。在这种情况下，创建、清除并销毁对象在我的机器上花了 66ns，这意味着如果你不适用安全网，为了保险你要付出 5（不是50）倍的代价。

**终止方法还有一个严重的安全问题：它们会使你的类受到终止方法攻击**（*finalizer attacks*）。终止方法攻击很简单：如果从构造器或它的序列化等价物——`readObject` 和 `readResolve` 方法（[第 12 条][Item12]）——抛出一个异常，恶意子类的终止方法就可以在部分构造的对象上运行，而这些对象本应该“死在藤蔓上”。这个终止方法可以在静态字段中记录对象的引用，从而防止对该对象进行垃圾回收。一旦记录了格式错误的对象（malformed object），在这个早就应该被销毁的对象上任意调用方法就会变得非常简单。**从构造器中抛出异常时，对象就不应该被创建，而终止方法面前却不是这样**。这样的攻击会导致可怕的结果。Final 类避免了终止方法攻击因为没人能给 final 类添加一个恶意子类。**为了让非 final 类避免终止方法攻击，请写一个不执行任何操作的 final 终止方法 **。

那么对于对象封装资源需要被终止的类，比如文件或线程相关类，不使用其终止方法或清除方法，你应该怎么做呢？**让你的类实现 `AutoCloseable` 接口**，并且让客户端在每个实例不在被需要时调用 `close` 方法，通常使用 `Try-with-resources` 保证一旦出现异常确保其终止（[第 9 条][Item9]）。有个值得注意的细节，实例必须持续跟踪它是否被关闭：`close` 方法必须在一个字段中记录该对象是无效的，然后另一个方法必须检查这个字段，如果在该对象已经被关闭后请求则抛出 `IllegalStateException` 异常。

那么，终止方法和清除方法有没有什么用处呢？它们可能有两种合法用途。

[Item9]: url	"在未来填入第 9 条的 url，否则无法进行跳转"
[Item12]: url	"在未来填入第 12 条的url，否则无法进行跳转"
[ThreadStop]: 为什么Thread,stop,Thread.suspend,Thread.resume和Runtime.runFinalizersOnExit会被贬低？	"https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPri"

