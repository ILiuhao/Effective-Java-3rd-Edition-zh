# 第 15 条：最小化类及其成员的可访问性

区分模块设计得是否良好，最重要的因素就是，该模块是否对其他模块隐藏了其内部数据和其他实现细节。拥有良好设计的模块会隐藏所有内部实现细节，明确的将其 API 和具体实现细节分割开来。然后，模块直接只能通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作细节。这种概念称为信息隐藏（*information hiding*）或封装（*encapsulation*），是软件设计的基础性原则。

出于种种原因，信息隐藏非常重要，其中大部分原因是因为它解耦了组成系统的各个组件，允许各组件独立地进行开发、测试、优化、应用、理解和修改。由于各组件可以各自独立地开发，从而加快了系统开发。由于可以更快地理解组件并进行调试或替换，而不必担心损害其他组件，从而减轻了维护的负担。虽然信息隐藏本身不会带来良好性能，但它可以有效地对性能进行有些优化：一旦系统完成，分析并确定是哪个组件导致的性能问题时（[第 67 条][Item67]），这些问题组件可以在不影响其他组件的同时进行优化。在开发中，低耦合的组件往往在其他环境中也是可用的，信息隐藏提高了软件的重用性。最后，信息隐藏降低了开发大型系统的风险，因为即使系统开发失败，组件也可以独立地开发成功。

Java 在信息隐藏方面有很多工具。访问控制（*access control* ）机制 [JSL，6.6] 明确规定了类、接口和成员的可访问性（*accessibility*）。实体的访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（**private, protected,** 和 **public**）决定的。这些修饰符的恰当使用对信息隐藏非常关键。

经验法则非常简单：**将每个类或成员都尽可能的设置为不可访问**。换句话说，使用与你正在编写的软件自身功能一致的尽可能低的访问级别。

对顶级（非嵌套的）类和接口而言，它们只有两种可能的访问级别：包级私有的（*package-private*）和公有的（*public*）。如果使用 public 修饰符声明顶级类或接口，该类或接口就会是公有的；否则其将会默认为包级私有的。如果顶级类或接口可以定义为包级私有的，它就应该定义为包级私有的。通过定义类或接口为包级私有的，可以将其作为实现的一部分，而不是暴露出去的 API，也可以在后续版本中修改、替换或删除这些类和接口，而不必担心损害已有的客户端。但如果你定义类或接口为公有的，那就必须永远保证该类和接口的兼容性。

如果只有一个类使用包级私有的顶级类或接口，那么考虑将该顶级类定义为唯一使用它的那个类的私有静态嵌套类（[第 24 条][Item24]）。这样就将顶级类或接口的可访问性从包中的所有类降低到了唯一使用它的类。但是，相比降低包级私有的顶级类的可访问性，降低不必要公有类的可访问性要重要的多：公有类是包的 API 的一部分，而包级私有的顶级类已经是它的实现细节的一部分了。

对成员（域、方法、嵌套类和嵌套接口）而言，有四个可能的访问级别，这里按照可访问性的递增次序列出：

- **private**——只有在声明该成员的顶级类内部才可以访问这个成员。
- **package-private**——可以在声明该成员的类所在包的任何一个类中方为这个成员。从技术上讲，称这种访问级别为默认访问级别（*default*），如果没有为成员指定任何访问修饰符，就采用这个访问级别。
- **protected**——可以在声明该成员的类的子类（但有一些限制 [ JSL, 6.6.2 ]），及声明该成员的类所在包的任何一个类中访问这个成员。
- **public**——可任意访问这个成员。

谨慎设计类的公有 API 后，你应该将所有成员设置为私有的。仅当位于同一包内的其他类确实需要访问成员时，才应该去掉 private 修饰符，让该成员成为包级私有的。如果你发现你经常需要这样做，那么就得重新审查系统的设计，看看另一种分解能否产生更好的相互解耦的类。这就是说，私有的和包级私有的成员都是类实现细节的一部分，通常不会影响该类暴露出去的 API。然而，如果类实现 Serializable 接口（[第 86 条][Item86] 和 [第 87 条][Item87]），这些域就可能会被“泄露（leak）”到导出的 API 中。

就公有类的成员来说，可访问性从包级私有到保护级别巨幅增加。受保护的成员是类所暴露 API 的一部分，必须永远维护。公有类的受保护成员也代表了该类对于某个实现细节的公开承诺（[第 19 条][Item19]）。受保护的成员应该尽量少用。

有一条关键规则限制了降低方法的可访问性的能力。如果一个方法覆盖了父类方法，那么在子类中该方法的可访问级别不能比父类中严苛 [ JSL, 8.4.8.3]。这样可以确保可使用父类实例的任何地方，都可以使用子类实例（*Liskov substitution principle*, 见[第 15 条][Item15]）。如果违反了这条原则，在编译子类时，编译器会产生错误信息。关于这条规则有个特殊情况，如果一个类实现了一个接口，那么接口中所有的类方法在这个类中也都必须声明为公有的。

[Item19]: url	"在未来填入第 19 条链接，否则无法跳转。"
[Item67]: url	"在未来填入第 67 条链接，否则无法跳转。"
[Item24]: url	"在未来填入第 24 条链接，否则无法跳转。"
[Item86]: url	"在未来填入第 86 条链接，否则无法跳转。"
[Item87]: url	"在未来填入第 87 条链接，否则无法跳转。"

